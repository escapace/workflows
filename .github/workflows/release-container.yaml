on:
  workflow_call:
    inputs:
      annotations-levels:
        default: index
        required: false
        type: string
      artifact-name:
        default: package
        description: 'artifact name'
        required: false
        type: string
      build-args:
        description: 'list of build-time variables'
        required: false
        type: string
      enable-cosign:
        default: false
        description: 'sign the resulting docker image(s)'
        required: false
        type: boolean
      enable-push:
        default: false
        description: 'push is a shorthand for --output=type=registry'
        required: false
        type: boolean
      enable-test:
        default: true
        description: 'run your tests when building the image'
        required: false
        type: boolean
      latest:
        description: 'add the latest tag'
        required: true
        type: boolean
      platforms:
        description: 'list of target platforms for build'
        required: false
        type: string
      prerelease:
        description: 'whether it is a prerelease'
        required: true
        type: boolean
      ref:
        required: true
        type: string
      version:
        required: true
        type: string
    # outputs:
    #   digest:
    #     description: 'image digest'
    #     value: ${{ jobs.main.outputs.digest }}
    #   image-id:
    #     description: 'image id'
    #     value: ${{ jobs.main.outputs.image-id }}
    #   metadata:
    #     description: 'build result metadata'
    #     value: ${{ jobs.main.outputs.metadata }}

# permissions:
#   packages: write
#   id-token: write

jobs:
  context:
    runs-on: ubuntu-latest
    outputs:
      archive: ${{ steps.context.outputs.archive }}
      packages: ${{ steps.context.outputs.packages }}
      platforms: ${{ steps.context.outputs.platforms }}
    steps:
      - name: download context archive
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact-name }}
      - name: extract context archive
        id: context
        shell: bash
        env:
          PLATFORMS: ${{ inputs.platforms }}
        run: |
          platforms="$(echo "${PLATFORMS}" | jq -c -R 'split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$"; ""))')"

          echo "platforms=${platforms}" >> "$GITHUB_OUTPUT"

          archive=""

          readarray -t archives < <(find "." -type f -name '*.tgz' -not -path '**/node_modules/**')

          while read -d '' -r file; do
            if tar -axOf "${file}" package/package.json package/pnpm-workspace.yaml &>/dev/null; then
              archive="${file}"
            fi
          done < <(find "." -type f -name '*.tgz' -not -path '**/node_modules/**' -print0 2>/dev/null)

          if [[ "${archive}" == "" ]]
          then
            while read -d '' -r file; do
              if [[ "$(tar -axOf "${file}" package/package.json | jq -r 'if .scripts["container:build"] | type == "string" then true else false end')" == "true" ]]; then
                archive="${file}"
              fi
            done < <(find "." -type f -name '*.tgz' -not -path '**/node_modules/**' -print0 2>/dev/null)
          fi

          echo "archive=${archive}" >> "$GITHUB_OUTPUT"

          tar -axf "${archive}"
          printf '%s\n' "${archives[@]}" | xargs rm -f

          declare -A packages=()

          while read -d '' -r file; do
            directory="$(dirname "$file")"

            if [[ -f "${directory}/package.json" &&
              -f "${directory}/Dockerfile" &&
              "$(jq -r 'if .scripts["container:build"] | type == "string" then true else false end' "$directory/package.json")" == "true" &&
              "$(jq -r 'if has("private") then .private else false end' "$directory/package.json")" == "true" &&
              "$(jq -r 'if .name | type == "string" and startswith("@container/") then true else false end' "$directory/package.json")" == "true" ]]; then
              name="$(jq -r '.name | sub("^@container/" ; "")' "${directory}/package.json")"
              dockerfile="${directory}/Dockerfile"
              packages["${name}"]="${dockerfile}"
            fi
          done < <(find "." -type f -name 'package.json' -not -path '**/node_modules/**' -print0 2>/dev/null)

          options="$(for i in "${!packages[@]}"; do echo "$i" && echo "${packages[$i]}"; done | jq -c -n -R 'reduce inputs as $i ([]; . + [[ $i, input ]]) | map({ name: .[0], dockerfile: .[1] } | tostring)')"

          echo "packages=${options}" >>"$GITHUB_OUTPUT"
  main:
    name: ${{ fromJSON(matrix.package).name }}
    needs:
      - context
    runs-on: ubuntu-latest
    strategy:
      matrix:
        archive:
          - ${{ needs.context.outputs.archive }}
        package: ${{ fromJSON(needs.context.outputs.packages) }}
        platform: ${{ fromJSON(needs.context.outputs.platforms) }}
    outputs:
      digest: ${{ steps.build-and-push.outputs.digest }}
      image-id: ${{ steps.build-and-push.outputs.imageid }}
      metadata: ${{ steps.build-and-push.outputs.metadata }}
    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
          ref: ${{ inputs.ref }}
      - name: container metadata
        id: container-metadata
        env:
          DOCKER_METADATA_ANNOTATIONS_LEVELS: ${{ inputs.annotations-levels }}
        uses: docker/metadata-action@v5
        with:
          context: git
          flavor: |
            latest=false
            prefix=
            suffix=
          images: ghcr.io/${{ github.repository_owner	}}/${{ fromJSON(matrix.package).name }}
          tags: |
            type=match,pattern=v(.*),group=1,value=v${{ inputs.version }}
            type=match,pattern=v(\d.\d),group=1,enable=${{ startsWith(inputs.version, '0') == false && inputs.prerelease == false }},value=v${{ inputs.version }}
            type=match,pattern=v(\d),group=1,enable=${{ startsWith(inputs.version, '0') == false && inputs.prerelease == false }},value=v${{ inputs.version }}
            type=raw,value=latest,enable=${{ inputs.latest && inputs.prerelease == false }}
      - name: remove the checkout
        shell: bash
        env:
          WORKSPACE: ${{ github.workspace }}
        run: |
          rm -rf "${WORKSPACE}"
          mkdir -p "${WORKSPACE}"
      - name: download context archive
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact-name }}
      - name: extract context archive
        shell: bash
        env:
          ARCHIVE: ${{ matrix.archive }}
        run: |
          readarray -t array < <(find . -type f -name '*.tgz')
          tar -xf "${ARCHIVE}"
          printf '%s\n' "${array[@]}" | xargs rm -f
      - name: docker login
        uses: docker/login-action@v3
        with:
          password: ${{ secrets.GITHUB_TOKEN }}
          registry: ghcr.io
          username: ${{ github.actor }}
      - name: setup qemu
        uses: docker/setup-qemu-action@v3
      - name: docker buildx
        id: buildx
        uses: docker/setup-buildx-action@v3
      - name: available platforms
        run: echo ${{ steps.buildx.outputs.platforms }}
      - uses: escapace/action-dockerfile-tools@v0.1.0
      - name: check whether there is a test stage
        id: dockerfile
        shell: bash
        env:
          DOCKERFILE: ${{ fromJSON(matrix.package).dockerfile }}
        run: |
          stages=$(dockerfile-tools list-stages --dockerfile "${DOCKERFILE}")

          if echo "$stages" | jq -e '.[] | select(. == "test")' > /dev/null; then
            echo "test=true" >> "$GITHUB_OUTPUT"
          else
            echo "test=false" >> "$GITHUB_OUTPUT"
          fi
      - name: normalize platform pair (replace / with -)
        id: platform
        run: |
          platform=${{ matrix.platform }}
          echo "value=${platform//\//-}" >> "$GITHUB_OUTPUT"
      - name: test
        if: fromJSON(steps.dockerfile.outputs.test) == true && inputs.enable-test == true
        id: test
        uses: docker/build-push-action@v5
        with:
          annotations: ${{ steps.container-metadata.outputs.annotations }}
          build-args: |
            CONTAINER_TEST=true
            ${{ inputs.build-args }}
          cache-from: |
            type=gha,scope=${{ fromJSON(matrix.package).name }}-${{ steps.platform.outputs.value }}
          # cache-to:
          context: .
          file: ${{ fromJSON(matrix.package).dockerfile }}
          labels: ${{ steps.container-metadata.outputs.labels }}
          platforms: ${{ matrix.platform }}
          provenance: false
          push: false
          sbom: false
          tags: ${{ steps.container-metadata.outputs.tags }}
          target: test
      - name: (re)build and push
        if: inputs.enable-push == true
        id: push
        uses: docker/build-push-action@v5
        with:
          annotations: ${{ steps.container-metadata.outputs.annotations }}
          build-args: ${{ inputs.build-args }}
          cache-from: |
            type=gha,scope=${{ fromJSON(matrix.package).name }}-${{ steps.platform.outputs.value}}
          cache-to: |
            type=gha,mode=max,scope=${{ fromJSON(matrix.package).name }}-${{ steps.platform.outputs.value}}
          context: .
          file: ${{ fromJSON(matrix.package).dockerfile }}
          labels: ${{ steps.container-metadata.outputs.labels }}
          platforms: ${{ inputs.platforms }}
          provenance: false
          push: ${{ inputs.enable-push }}
          sbom: false
          tags: ${{ steps.container-metadata.outputs.tags }}
      - name: install cosign
        if: inputs.enable-cosign == true && inputs.enable-push == true
        uses: sigstore/cosign-installer@v3.7.0
        # with:
        #   cosign-release: 'v2.1.1'
      - name: sign the docker image
        if: inputs.enable-cosign == true && inputs.enable-push == true
        env:
          DIGEST: ${{ steps.push.outputs.digest }}
          # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
          TAGS: ${{ steps.container-metadata.outputs.tags }}
        run: |
          echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}
      # adapted from https://docs.docker.com/build/ci/github-actions/multi-platform/
      - name: create manifest list and push
        if: inputs.enable-push == true
        shell: bash
        env:
          ANNOTATIONS: ${{ steps.container-metadata.outputs.annotations }}
          DIGEST: ${{ steps.push.outputs.digest }}
          SOURCE: ghcr.io/${{ github.repository_owner	}}/${{ fromJSON(matrix.package).name }}
          TAGS: ${{ steps.container-metadata.outputs.tags }}
        run: |
          readarray -t lines <<< "$ANNOTATIONS"; annotations=(); for line in "${lines[@]}"; do annotations+=(--annotation "$line"); done
          readarray -t lines <<< "$TAGS"; tags=(); for line in "${lines[@]}"; do tags+=(-t "$line"); done
          docker buildx imagetools create \
          "${annotations[@]}" "${tags[@]}" "${SOURCE}@${DIGEST}"
      # - if: inputs.enable-push == true
      #   name: attest
      #   uses: actions/attest-build-provenance@v1
      #   with:
      #     push-to-registry: true
      #     subject-digest: ${{ steps.push.outputs.digest }}
      #     subject-name: ghcr.io/${{ github.repository }}
